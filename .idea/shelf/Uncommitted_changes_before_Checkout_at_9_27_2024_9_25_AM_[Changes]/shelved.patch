Index: src/flowchem/components/valves/valve.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"Generic valve.\"\"\"\r\nfrom __future__ import annotations\r\n\r\nfrom pydantic import BaseModel\r\nimport json\r\n\r\nfrom flowchem.components.flowchem_component import FlowchemComponent\r\nfrom flowchem.devices.flowchem_device import FlowchemDevice\r\nfrom flowchem.utils.exceptions import InvalidConfigurationError, DeviceError\r\n\r\n\r\ndef return_tuple_from_input(str_or_list):\r\n    # in case no input is given simply return None, will be dealt with by consumer\r\n    if not str_or_list:\r\n        return None\r\n    elif type(str_or_list) is str:\r\n        parsed_input = json.loads(str_or_list)\r\n        if type(parsed_input[0]) is not list:\r\n            parsed_input = [parsed_input]\r\n        return tuple(tuple(inner) for inner in parsed_input)\r\n    # if nested list is given, return nested tuple\r\n    elif type(str_or_list) is list:\r\n        return tuple([tuple(to_tuple) for to_tuple in str_or_list])\r\n    else:\r\n        raise DeviceError(\"Please provide input of type nested list, e.g. '[[1,2],[3,4]]'\")\r\n\r\n\r\ndef return_bool_from_input(str_or_bool):\r\n    if type(str_or_bool) is bool:\r\n        return str_or_bool\r\n    elif type(str_or_bool) is str:\r\n        if str_or_bool.lower() == \"true\":\r\n            return True\r\n        elif str_or_bool.lower() == \"false\":\r\n            return False\r\n        elif str_or_bool == \"\":\r\n            return None\r\n        else:\r\n            raise DeviceError(\"Please provide input of type bool, '' or 'True' or 'False'\")\r\n\r\n\r\nclass ValveInfo(BaseModel):\r\n    \"\"\"\r\n    ports: an attribute representing the available ports on the stator\r\n    positions: an attribute mapping implicit, tacit numbers as keys to the stator ports that are connected at this\r\n                position\r\n    \"\"\"\r\n    ports: list[tuple]\r\n    positions: dict[int, tuple[tuple[None | int, ...], ...]]\r\n\r\n\r\ndef all_tuples_in_nested_tuple(tuple_in: tuple[tuple[int, int], ...],\r\n                               tuple_contains: tuple[tuple[int, int, ...], ...]) -> bool:\r\n    \"\"\"Check if all requested tuples are in a tuple of tuples\"\"\"\r\n    all_contained = []\r\n    for subtuple in tuple_in:\r\n        for supertuple in tuple_contains:\r\n            if set(subtuple) <= set(supertuple):\r\n                all_contained.append(True)\r\n                break\r\n    if len(all_contained) == len(tuple_in):\r\n        return True\r\n    else:\r\n        return False\r\n\r\n\r\ndef no_tuple_in_nested_tuple(tuple_in: tuple[tuple[int, int], ...],\r\n                             tuple_contains: tuple[tuple[int, int, ...], ...]) -> bool:\r\n    \"\"\"Check if none of requested tuples are in a tuple of tuples\"\"\"\r\n    contains_tuple = False\r\n    for subtuple in tuple_in:\r\n        for supertuple in tuple_contains:\r\n            if set(subtuple) <= set(supertuple):\r\n                contains_tuple = True\r\n    return not contains_tuple\r\n\r\n\r\nclass Valve(FlowchemComponent):\r\n    \"\"\"An abstract class for devices of type valve.\r\n\r\n    .. warning::\r\n        Device objects should not directly generate components with this object but rather a more specific valve type,\r\n        such as `SixPortTwoPositionValve` or `SixPortPositionValve`.\r\n\r\n    All valves are characterized by:\r\n\r\n    - a connections() method, which returns an Instance of the ValveInfo class\r\n    - a `set_position()` method\r\n    - a `get_position()` method\r\n\r\n    This is explicit and informative in itself and requires no further intermittant helper mappings\r\n    \"\"\"\r\n\r\n    def __init__(\r\n            self,\r\n            name: str,\r\n# todo maybe create a subclass from Flowchem Device, namely Flowchem valve, which implements abstract methods get_raw_position and set_raw_position\r\n            hw_device: FlowchemDevice,\r\n            stator_ports: [(), ()],\r\n            rotor_ports: [(), ()],\r\n    ) -> None:\r\n        \"\"\"Create a valve object.\r\n\r\n        Args:\r\n        ----\r\n            name: device name, passed to FlowchemComponent.\r\n            hw_device: the object that controls the hardware.\r\n            stator_ports\r\n            rotor_ports\r\n            rotor and stator are both represented like:\r\n            (   (1,2,3,4,5,6),          (0))\r\n                radial ports       middle ports\r\n            Ports should be equally distributed, with equally spaced angle in between. If this is not the case, add None\r\n             for missing port\r\n\r\n        \"\"\"\r\n        # a valve consists of a rotor and a stator. Solenoid valves Are special cases and can be decomposed into\r\n        # Open/closed valves, need not be treated here but could be simulated by a [1,2,None] and rotor [3,3,None]\r\n        self._rotor_ports = rotor_ports\r\n        self._stator_ports = stator_ports\r\n        self._positions = self._create_connections(self._stator_ports, self._rotor_ports)\r\n\r\n        # bwe can infer\r\n        super().__init__(name, hw_device)\r\n\r\n        self.add_api_route(\"/position\", self.get_position, methods=[\"GET\"])\r\n        self.add_api_route(\"/position\", self.set_position, methods=[\"PUT\"])\r\n        self.add_api_route(\"/connections\", self.connections, methods=[\"GET\"])\r\n\r\n    def _create_connections(self, stator_ports, rotor_ports):\r\n        \"\"\"\r\n        Create possible switching states from a stator and rotor representation. Position names are integers. Going to\r\n        the next position in clockwise direction increases position name by one\r\n        \"\"\"\r\n        connections = {}\r\n        if len(rotor_ports) != len(stator_ports):\r\n            raise InvalidConfigurationError\r\n        if len(rotor_ports) == 1:\r\n            # in case there is no 0 port, for data uniformity, internally add it. strictly, the stator and rotor\r\n            # should reflect physical properties, so if stator has a hole in middle it should have 0, but only rotor\r\n            # None. Sinc ethis does not impact functionality, thoroughness will be left to the user\r\n            rotor_ports.append([None])\r\n            stator_ports.append([None])\r\n        # it is rather simple: we just move the rotor by one and thereby create a dictionary\r\n        for _ in range(len(rotor_ports[0])):\r\n            rotor_curr = rotor_ports[0][-_:] + rotor_ports[0][:-_]\r\n            _connections_per_position = {}\r\n            for rotor_position, stator_position in zip(rotor_curr + rotor_ports[1], stator_ports[0] + stator_ports[1]):\r\n                # rotor positions act as dictionary keys, take into account the [1] position for connecting the 0\r\n                # if dict key exists, instead of overwriting, simply append\r\n                # if rotor is none, means there is no connection, so do not add\r\n                if rotor_position is not None:\r\n                    try:\r\n                        _connections_per_position[rotor_position] += (stator_position,)\r\n                    except KeyError:\r\n                        _connections_per_position[rotor_position] = (stator_position,)\r\n                        # get rid of the keys, values are the connected ports in each position\r\n            connections[_] = tuple(_connections_per_position.values())\r\n        # lastly, trim the lists of connections that already exist\r\n        # trim returned connections\r\n        unique_connections = set(connections.values())\r\n        to_delete = []\r\n        for connection in unique_connections:\r\n            counter = 0\r\n            for key, value in connections.items():\r\n                if connection == value:\r\n                    if counter > 0:\r\n                        to_delete.append(key)\r\n                    counter += 1\r\n        for _ in to_delete:\r\n            del connections[_]\r\n\r\n        return connections\r\n\r\n    def _change_connections(self, raw_position: int, reverse: bool = False) -> str:\r\n        # abstract valve mapping needs to be translated to device-specific position naming. This can be eg\r\n        # addition/subtraction of one, multiplication with some angle or mapping to letters. Needs to be implemented on\r\n        # device level since this is device communication protocol specific\r\n        raise NotImplementedError\r\n\r\n    def _connect_positions(self,\r\n                           positions_to_connect: tuple[tuple[int, int],...],\r\n                           positions_not_to_connect: tuple[tuple[int, int],...] = None,\r\n                           arbitrary_switching: bool = True) -> int:\r\n        \"\"\"\r\n        This is the heart of valve switching logic: select the suitable position (so actually the key in\r\n        self._positions) to create desired connections\r\n        \"\"\"\r\n        possible_positions = []\r\n        # check if this is possible given the mapping\r\n        for key, values in self._positions.items():\r\n            if positions_not_to_connect:\r\n                if all_tuples_in_nested_tuple(positions_to_connect, values) and no_tuple_in_nested_tuple(\r\n                        positions_not_to_connect, values):\r\n                    possible_positions.append(key)\r\n            elif all_tuples_in_nested_tuple(positions_to_connect, values):\r\n                possible_positions.append(key)\r\n        if len(possible_positions) > 1:\r\n            if not arbitrary_switching:\r\n                raise DeviceError(\"There are multiple positions for the valve to connect your specified ports. \"\r\n                                  \"Either allow arbitrary switching, or specify which connections not to connect\")\r\n            elif arbitrary_switching:\r\n                return possible_positions[0]\r\n            else:\r\n                raise DeviceError\r\n        elif len(possible_positions) == 1:\r\n            return possible_positions[0]\r\n        else:\r\n            # this means length == 0, no connection possible\r\n            raise DeviceError(\"Connection is not possible. The valve you selected can not connect selected ports.\"\r\n                              \"This can be due to exclusion of certain connections by setting positions_not_to_connect\")\r\n\r\n    async def get_position(self) -> list[list[int, int], ...]:\r\n        \"\"\"Get current valve position.\"\"\"\r\n        if not hasattr(self, \"identifier\"):\r\n            pos = await self.hw_device.get_raw_position()\r\n        else:\r\n            pos = await self.hw_device.get_raw_position(self.identifier)\r\n        pos = int(pos) if pos.isnumeric() else pos\r\n        return_value = self._positions[int(self._change_connections(pos, reverse=True))]\r\n        return [list(value) for value in return_value]\r\n\r\n    async def set_position(self, connect: list[list[int, int], ...] = None, disconnect: list[list[int, int], ...] = None,\r\n                           ambiguous_switching: str | bool = False):\r\n        \"\"\"Move valve to position, which connects named ports\"\"\"\r\n        connect= return_tuple_from_input(connect)\r\n        disconnect= return_tuple_from_input(disconnect)\r\n        ambiguous_switching=return_bool_from_input(ambiguous_switching)\r\n        target_pos = self._connect_positions(positions_to_connect=connect, positions_not_to_connect=disconnect,\r\n                                             arbitrary_switching=ambiguous_switching)\r\n        target_pos = self._change_connections(target_pos)\r\n        if not hasattr(self, \"identifier\"):\r\n            await self.hw_device.set_raw_position(target_pos)\r\n        else:\r\n            await self.hw_device.set_raw_position(target_pos, target_component=self.identifier)\r\n\r\n\r\n    def connections(self) -> ValveInfo:\r\n        \"\"\"Get the list of all available positions for this valve.\r\n        This mainly has informative purpose\r\n        \"\"\"\r\n        return ValveInfo(ports=self._stator_ports, positions=self._positions)\r\n\r\n    # Philosophy: explicitly specify which ports to connect\r\n    # In case of a simple multiposition valve, it always connects the always open central port to the requested port.\r\n    # But there are more complex rotors available, already with an injection valve: connect((1, 2)) is concise and clear.\r\n    # What is even more important, one can specify which ports to not connect (optionally during switching)\r\n    # This issue is most pressing with hamilton valves, where some positions connect 3 ports and it is very hard to\r\n    # foresee what command does what. SO here a simple connect((1,2)) helps.\r\n    # In order for that to work, and to make the coding and usage simple and concise, some definitions are needed:\r\n    # 1) The port zero can exist, but does not necessarily.\r\n    #    For nomenclature reasons, port zero is the one the turning axis and only this one. COmmonly, this port,\r\n    #    if existing, is always open\r\n    # 2) At the physical valve, the upmost is port 1\r\n    #   a) If there is no port straight on top, then one goes in clockwise direction, until a port comes, which is then one\r\n    # 3 )Beware: For logical reasons, we need to introduce ports of \"number\" None. These are needed because we need to\r\n    #   define dead-ends. These dead-ends are IMMUTABLE dead-ends, so the stator or rotor do not have an opening there\r\n    #   Any time there is a different amount of positions on rotor and stator, Noneports are introduced\r\n    # 5) Mutable dead-ends: blanking plugs are treated as port number, the consumer needs to deal with its definition by\r\n    #   graph or similar since blanking plugs on valve side could be open\r\n    # Dead-ends are needed because we represent valves as graphs, edges are represented by same numbers shared. If a\r\n    # port does not connect to anything, we set it None. There is 1 example where that is strictly needed for the logic\r\n    # to work: Again the hamilton, it will become clear why. So much now: The rotor has more open positions than the\r\n    # stator.\r\n    # 6) The so far mentioned logic only strictly applies to valves facing the user with their front side, however,\r\n    # e.g. the autosampler faces one valve with its always open port to the ground. Simply flip horizontally until it\r\n    # faces you\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/flowchem/components/valves/valve.py b/src/flowchem/components/valves/valve.py
--- a/src/flowchem/components/valves/valve.py	
+++ b/src/flowchem/components/valves/valve.py	
@@ -2,11 +2,13 @@
 from __future__ import annotations
 
 from pydantic import BaseModel
+from typing import List
 import json
 
 from flowchem.components.flowchem_component import FlowchemComponent
 from flowchem.devices.flowchem_device import FlowchemDevice
 from flowchem.utils.exceptions import InvalidConfigurationError, DeviceError
+from loguru import logger
 
 
 def return_tuple_from_input(str_or_list):
@@ -210,7 +212,7 @@
             raise DeviceError("Connection is not possible. The valve you selected can not connect selected ports."
                               "This can be due to exclusion of certain connections by setting positions_not_to_connect")
 
-    async def get_position(self) -> list[list[int, int], ...]:
+    async def get_position(self) -> list[Any,]:
         """Get current valve position."""
         if not hasattr(self, "identifier"):
             pos = await self.hw_device.get_raw_position()
@@ -220,15 +222,20 @@
         return_value = self._positions[int(self._change_connections(pos, reverse=True))]
         return [list(value) for value in return_value]
 
-    async def set_position(self, connect: list[list[int, int], ...] = None, disconnect: list[list[int, int], ...] = None,
+    async def set_position(self, connect: list[list[int,int]] = None, disconnect: list[list[int,int]] =
+    None,
                            ambiguous_switching: str | bool = False):
         """Move valve to position, which connects named ports"""
         connect= return_tuple_from_input(connect)
+        logger.info(connect)
         disconnect= return_tuple_from_input(disconnect)
+        logger.info(disconnect)
         ambiguous_switching=return_bool_from_input(ambiguous_switching)
         target_pos = self._connect_positions(positions_to_connect=connect, positions_not_to_connect=disconnect,
                                              arbitrary_switching=ambiguous_switching)
+        logger.info(target_pos)
         target_pos = self._change_connections(target_pos)
+        logger.info(target_pos)
         if not hasattr(self, "identifier"):
             await self.hw_device.set_raw_position(target_pos)
         else:
